diff --git a/backend/app_factory.py b/backend/app_factory.py
--- a/backend/app_factory.py
+++ b/backend/app_factory.py
@@ -71,6 +71,11 @@
     # Register the single experimental router with the main app.
     app.include_router(experimental_router)

+    # --- Unified Interoperability Router ---
+    # This is the NEW primary entry point for all stable, interoperable functionality.
+    from backend.app.api import unified_router
+    app.include_router(unified_router.router)
+
     # --- Legacy & Stable Routers ---
     app.include_router(core.router, prefix="/api/v1", tags=["Core (Legacy)"])
     app.include_router(ingestion_orchestrator.router, prefix="/api/v1", tags=["Ingestion Orchestrator"])
diff --git a/backend/app/api/unified_router.py b/backend/app/api/unified_router.py
new file mode 100644
--- /dev/null
+++ b/backend/app/api/unified_router.py
@@ -0,0 +1,71 @@
+# backend/app/api/unified_router.py
+
+"""
+The Unified API Router for SADI.
+
+This router serves as the single, stable entry point for all frontend operations.
+It completely decouples the client from the complex and conflicting backend architectures.
+
+Each endpoint defined here will delegate its logic to the InteropController,
+which will then use the appropriate bridge to fulfill the request.
+"""
+
+from fastapi import APIRouter, Depends, UploadFile, File, Body, Request
+from backend.interoperability.controller import InteropController, get_interop_controller
+
+router = APIRouter(prefix="/unified/v1", tags=["Unified Stable Endpoints"])
+
+# NOTE: The implementation of these endpoints is intentionally minimal.
+# They are simple pass-throughs to the interoperability controller,
+# which holds the responsibility of orchestrating the complex logic.
+
+from backend.interoperability.data_bridge import DataBridge, get_data_bridge
+
+@router.post("/ingestion/upload-file")
+async def unified_ingestion(
+    file: UploadFile = File(...),
+    data_bridge: DataBridge = Depends(get_data_bridge)
+):
+    """
+    Unified endpoint for file ingestion. Always persistent.
+    """
+    # DELEGATION: This endpoint now directly calls the data bridge.
+    return await data_bridge.bridge_ingestion(file)
+
+from backend.interoperability.session_bridge import SessionBridge, get_session_bridge
+
+@router.post("/session/create")
+async def unified_create_session(
+    session_bridge: SessionBridge = Depends(get_session_bridge)
+):
+    """
+    Unified endpoint for creating a session. Always persistent.
+    """
+    # DELEGATION: This endpoint now directly calls the session bridge.
+    return session_bridge.bridge_create_session()
+
+@router.post("/chat/agent")
+async def unified_chat_agent(
+    request: Request,
+    controller: InteropController = Depends(get_interop_controller)
+):
+    """
+    Unified endpoint for the chat agent.
+    """
+    # In FASE 3, this will call:
+    # payload = await request.json()
+    # return await controller.bridge_chat(payload)
+    return {"message": "Unified chat agent endpoint is active", "status": "pending_implementation"}
+
+# Additional unified endpoints for EDA, quality, ML, etc., will be added here.
diff --git a/backend/interoperability/__init__.py b/backend/interoperability/__init__.py
new file mode 100644
--- /dev/null
+++ b/backend/interoperability/__init__.py
@@ -0,0 +1,1 @@
+# This file makes the 'interoperability' directory a Python package.
diff --git a/backend/interoperability/controller.py b/backend/interoperability/controller.py
new file mode 100644
--- /dev/null
+++ b/backend/interoperability/controller.py
@@ -0,0 +1,54 @@
+# backend/interoperability/controller.py
+
+"""
+Main controller for the Interoperability Layer.
+
+This module will contain the core logic for routing and translating requests
+between the legacy architecture and the new MCP/MPA/WPA architecture.
+It will act as a central dispatcher, ensuring that data flows correctly
+and consistently, regardless of the underlying implementation being called.
+"""
+
+from pathlib import Path
+import datetime
+
+# --- Configuration for Audit Logging ---
+LOG_DIR = Path("data/logs/interops")
+LOG_DIR.mkdir(parents=True, exist_ok=True)
+LOG_FILE = LOG_DIR / "unified_api_log.txt"
+
+class InteropController:
+    """
+    Orchestrates calls by bridging the gap between the unified API layer
+    and the two coexisting architectures.
+    """
+    def __init__(self):
+        # In future steps, this will be initialized with registry and bridges.
+        pass
+
+    def _log_audit_event(self, endpoint_name: str, details: str):
+        """Logs an auditable event for a unified API call."""
+        timestamp = datetime.datetime.utcnow().isoformat()
+        log_message = f"[{timestamp}] - ENDPOINT: {endpoint_name} - DETAILS: {details}\n"
+        with open(LOG_FILE, "a") as f:
+            f.write(log_message)
+
+    def route_ingestion(self, *args, **kwargs):
+        """Routes an ingestion request."""
+        # Logic to call the appropriate bridge will be implemented here.
+        pass
+
+    def route_chat(self, *args, **kwargs):
+        """Routes a chat agent request."""
+        # Logic to call the appropriate bridge will be implemented here.
+        pass
+
+# Singleton instance for the controller
+interop_controller = InteropController()
+
+def get_interop_controller() -> InteropController:
+    return interop_controller
diff --git a/backend/interoperability/data_bridge.py b/backend/interoperability/data_bridge.py
new file mode 100644
--- /dev/null
+++ b/backend/interoperability/data_bridge.py
@@ -0,0 +1,48 @@
+# backend/interoperability/data_bridge.py
+
+"""
+Data Bridge for the Interoperability Layer.
+
+This module is responsible for bridging the data ingestion functionalities.
+Specifically, it will adapt the new, non-persistent MPA ingestion endpoint
+to use the robust, persistent logic of the legacy IngestionOrchestrator.
+"""
+
+from backend.app.api.ingestion_orchestrator import IngestionOrchestratorService
+
+class DataBridge:
+    """
+    Translates and unifies data-related operations.
+    """
+    def __init__(self):
+        # The service is instantiated on demand, consistent with legacy approach.
+        self._ingestion_service = IngestionOrchestratorService()
+
+    async def bridge_ingestion(self, file):
+        """
+        Bridges the MPA file upload to the legacy persistent storage pattern.
+
+        1. Receives a file from a unified endpoint.
+        2. Calls the legacy IngestionOrchestrator to process and save the file.
+        3. Returns a consistent response, including a session_id, which the MPA
+           endpoint did not originally provide.
+        """
+        session_id = await self._ingestion_service.process_single_file(file)
+
+        # Log the audit event
+        from .controller import get_interop_controller
+        get_interop_controller()._log_audit_event(
+            endpoint_name="/ingestion/upload-file",
+            details=f"Persisted file '{file.filename}' to session ID: {session_id}"
+        )
+
+        return {
+            "message": "File processed and persisted via Interoperability Bridge.",
+            "session_id": session_id,
+            "filename": file.filename,
+            "persistence_mode": "stable"
+        }
+
+# Singleton instance for the data bridge
+data_bridge = DataBridge()
+
+def get_data_bridge() -> DataBridge:
+    return data_bridge
diff --git a/backend/interoperability/registry.py b/backend/interoperability/registry.py
new file mode 100644
--- /dev/null
+++ b/backend/interoperability/registry.py
@@ -0,0 +1,42 @@
+# backend/interoperability/registry.py
+
+"""
+Service and Endpoint Registry for the Interoperability Layer.
+
+This module will maintain a mapping of unified endpoint definitions to their
+actual implementations in either the legacy or the new architecture. This allows
+the InteropController to dynamically dispatch requests without hardcoding routes.
+"""
+
+class EndpointRegistry:
+    """
+    Provides a centralized registry of available endpoints from both
+    legacy and new architectures.
+    """
+    def __init__(self):
+        self._registry = {
+            "unified/v1/ingestion": {
+                "legacy": "ingestion_orchestrator.unified_upload",
+                "mpa": "mpa.ingestion.upload_file",
+                "bridge": "data_bridge.bridge_ingestion"
+            },
+            "unified/v1/sessions": {
+                "mcp": "mcp.api.create_session",
+                "bridge": "session_bridge.bridge_create_session"
+            }
+            # More endpoints will be registered here.
+        }
+
+    def get_endpoint_implementations(self, unified_route: str):
+        """
+        Retrieves the available implementations for a given unified route.
+        """
+        return self._registry.get(unified_route)
+
+# Singleton instance for the registry
+endpoint_registry = EndpointRegistry()
+
+def get_endpoint_registry() -> EndpointRegistry:
+    return endpoint_registry
diff --git a/backend/interoperability/session_bridge.py b/backend/interoperability/session_bridge.py
new file mode 100644
--- /dev/null
+++ b/backend/interoperability/session_bridge.py
@@ -0,0 +1,52 @@
+# backend/interoperability/session_bridge.py
+
+"""
+Session Bridge for the Interoperability Layer.
+
+This module's primary responsibility is to solve the critical issue of
+MCP's in-memory, volatile persistence. It will bridge session and job
+management calls to the stable, file-based legacy StateStore.
+"""
+
+import uuid
+from backend.app.services.state_store import StateStore, get_state_store
+
+class SessionBridge:
+    """
+    Translates MCP session operations to use the legacy StateStore.
+    """
+    def __init__(self, state_store: StateStore = get_state_store()):
+        self._state_store = state_store
+
+    def bridge_create_session(self):
+        """
+        Handles the creation of a session, ensuring it is persisted
+        in the legacy StateStore instead of the MCP's in-memory dictionary.
+        """
+        # Generate a new session ID
+        session_id = str(uuid.uuid4())
+
+        # Use the persistent state store to create the session
+        self._state_store.create_session(session_id)
+
+        # For now, manually log the audit event. Later, this could be a decorator.
+        from .controller import get_interop_controller
+        get_interop_controller()._log_audit_event(
+            endpoint_name="/session/create",
+            details=f"Persisted new session with ID: {session_id}"
+        )
+
+        # Return a response consistent with the expected format
+        return {
+            "message": "Session created and persisted via Interoperability Bridge.",
+            "session_id": session_id,
+            "persistence_mode": "stable"
+        }
+
+# Singleton instance for the session bridge
+# The dependency is resolved at instantiation time.
+session_bridge = SessionBridge()
+
+def get_session_bridge() -> SessionBridge:
+    return session_bridge